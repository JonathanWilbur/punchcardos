/* Minimal ar implementation needed to build the Linux kernel. This compiles
with nolibc.

Copyright (c) 2024 by Jonathan M. Wilbur. Released under an MIT License.
*/
#include <linux/limits.h>
#ifndef NOLIBC
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <libgen.h> /* dirname */
#include <sys/stat.h>

#ifdef __GLIBC__

static char itoa_buffer[21];

// Intentionally non-reentrant, like nolibc's implementation, specifically so
// we do not have to free memory each time we stringify an integer.
char *itoa(long in)
{
    snprintf(itoa_buffer, sizeof(itoa_buffer), "%ld", in);
    return itoa_buffer;
}

long atol (const char* s) {
    long ret = 0;
    for (int i = 0; i < strlen(s); i++) {
        char c = s[i];
        if (c < '0' || c > '9') {
            break;
        }
        ret = (ret * 10) + (c - '0');
    }
    return ret;
}

#endif

#else

#define	F_OK	0

static char *dirname (char *path) {
    int len = strlen(path);

    // Real dirname returns a period if supplied an empty string.
    if (len == 0) {
        return ".";
    }

    int i = len - 1;
    int prev_was_slash = 0;
    for (; i >= 0; i--) {
        if (path[i] == '/') {
            goto is_dir;
        }
    }

    // Real dirname returns a period if there are no slashes.
    return ".";

    is_dir:
    for (; i >= 0; i--) {
        if (path[i] != '/') {
            break;
        }
        path[i] = 0;
    }

    // If the string was all slashes, return a single slash.
    if (strlen(path) == 0) {
        return "/";
    }

    return path;
}

int access (const char *pathname, int mode) {
    return __sysret(my_syscall2(__NR_access, pathname, mode));
}

#endif

#define FLAG_CREATE     (1 << 0) /* c modifier */
#define FLAG_INDEX      (1 << 1) /* s modifier */
#define FLAG_FULL_PATH  (1 << 2) /* P modifier */
#define FLAG_THIN       (1 << 3) /* T modifier */
#define FLAG_INSERT     (1 << 4) /* i modifier */
#define FLAG_DETERM     (1 << 5) /* D modifier */
#define FLAG_NO_SYMS    (1 << 6) /* S modifier */

#define SUBCMD_UNKNOWN  0
#define SUBCMD_REPLACE  1   /* r operation */
#define SUBCMD_LIST     2   /* t operation */
#define SUBCMD_MOVE     3   /* m operation */

#define ARMAG                   "!<arch>\012" /* COFF and a.out archives. */
#define ARMAGT                  "!<thin>\012" /* Thin archives. */
#define SARMAG                  8
#define ARFMAG                  "`\012"
#define ARMAP_TIME_OFFSET       60

struct ar_header {
    char name[16];
    char date[12];
    char uid[6];
    char gid[6];
    char mode[8];
    char size[10];
    char fmag[2];
};

// I cannot find documentation of this anywhere. This was generated by ChatGPT.
struct ar_longname {
    char ar_name[16]; // 'longname' string to indicate this is a long name entry
    char ar_size[10];
    char ar_fmag[2]; // Magic number; must be `AR` (0x60 0x0A)
    // Followed by the long name string itself
};

static int ar_thin_list (int fd, int flags, char *archive_name) {
    ssize_t rc;
    struct ar_header hdr;
    long size;
    int namelen;
    char *filenames = NULL;
    long name_offset;
    /* This modifies archive_name by reference, but we're done with it anyway. */
    char *dir = dirname(archive_name);
    char fullpath[PATH_MAX];
    size_t dirlen = strlen(dir);
    
    strcpy(fullpath, dir);
    fullpath[dirlen] = '/';
    fullpath[dirlen + 1] = '\0';

    while ((rc = read(fd, &hdr, sizeof(hdr))) > 0) {
        if (!strncmp(hdr.name, "//", 2)) {
            size = atol(hdr.size);
            filenames = malloc(size + 1);
            if (filenames == NULL) {
                errno = ENOMEM;
                perror("malloc long file names");
                return EXIT_FAILURE;
            }
            if (read(fd, filenames, size) != size) {
                perror("read file names");
                return EXIT_FAILURE;
            }
            filenames[size] = 0;
            for (int i = 0; i < size; i++) {
                // TODO: I think you may have to fix the '/' replacement.
                // I think full-path thin archives can have / in names.
                if (filenames[i] == '\n' || filenames[i] == '/')
                    filenames[i] = '\0';
            }
            break;
        }
    }
    if (filenames == NULL) {
        puts("No long filenames in thin archive.");
        return EXIT_FAILURE;
    }
    if (rc < 0) {
        perror("read ar header");
        return EXIT_FAILURE;
    }
    if (lseek(fd, 8, SEEK_SET) != 8) {
        perror("lseek to end of ar header");
        return EXIT_FAILURE;
    }
    while ((rc = read(fd, &hdr, sizeof(hdr))) > 0) {
        if (!strncmp(hdr.name, "//", 2)) {
            size = atol(hdr.size);
            /* the "//" file is the only one whose size is truthful in a thin
            archive, and maybe the symbol table "/" too. */
            if (lseek(fd, size, SEEK_CUR) < 0) {
                perror("seek ahead by file");
                return EXIT_FAILURE;
            }
            continue; // Long names are stored in this section.
        }
        hdr.name[15] = '/';
        for (namelen = 0; namelen < 15; namelen++) {
            if (hdr.name[namelen] == '/') {
                hdr.name[namelen] = '\0';
                break;
            }
        }
        // TODO: I am not sure what the "/" name means.
        if (strlen(hdr.name) > 0) {
            strcpy(&fullpath[dirlen + 1], hdr.name);
            puts(fullpath);
        } else {
            // TODO: I think you need to check if it is a "/" file.
            name_offset = atol(&hdr.name[1]);
            strcpy(&fullpath[dirlen + 1], &filenames[name_offset]);
            puts(fullpath);
        }
    }
    if (rc < 0) {
        perror("read ar file header");
        return EXIT_FAILURE;
    }
    free(filenames);
    close(fd);
    return EXIT_SUCCESS;
}

static int ar_arch_list (int fd, int flags) {
    ssize_t rc;
    struct ar_header hdr;
    long size;
    int namelen;

    while ((rc = read(fd, &hdr, sizeof(hdr))) > 0) {
        if (!strncmp(hdr.name, "//", 2))
            continue; // FIXME: Handle this?
        hdr.name[15] = '/';
        for (namelen = 0; namelen < 15; namelen++) {
            if (hdr.name[namelen] == '/') {
                hdr.name[namelen] = '\0';
                break;
            }
        }
        if (strlen(hdr.name) > 0)
            puts(hdr.name);
        size = atol(hdr.size);
        if (lseek(fd, size, SEEK_CUR) < 0) {
            perror("seek ahead by file");
            return EXIT_FAILURE;
        }
    }
    if (rc < 0) {
        perror("read ar header");
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

static int ar_list (char *archive_name, int flags) {
    int fd = open(archive_name, O_RDONLY);
    char magicbuf[8];
    int thin = 0;

    if (fd < 0) {
        perror(archive_name);
        return EXIT_FAILURE;
    }

    if (read(fd, &magicbuf, sizeof(magicbuf)) != sizeof(magicbuf)) {
        perror("read ar magic");
        return EXIT_FAILURE;
    }

    if (strcmp(&magicbuf[0], ARMAG) != 0) {
        if (!strcmp(&magicbuf[0], ARMAGT)) {
            thin = 1;
        } else {
            puts("Not a GNU archive.");
            return EXIT_FAILURE;
        }
    }

    if (thin)
        return ar_thin_list(fd, flags, archive_name);
    return ar_arch_list(fd, flags);
}

/*
TLDR:
The move subcommand "m" is used one time in building the Linux kernel and it is
a no-op on x86-64, so this is a no-op.

INVOCATION:
ar mPiT $(ar t vmlinux.a | sed -n 1p) vmlinux.a $(ar t vmlinux.a | grep -F -f ./scripts/head-object-list.txt)

DETAILS:
The invocation above means "move/insert the following members to be before
the argument specified in [relpos]" and since the relpos argument is just the
first file in the archive, it effectively means, "put these members at the top
of the archive."

...and upon looking in the head-object-list.txt, because none of the objects in
that list are even compiled on x86-64, it looks like this is a no-op on x86-64,
which is why this is just a no-op function. If this is ever ported to other
architectures, this may need to change.
*/
static int ar_move (char *archive_name, int flags) {
    return EXIT_SUCCESS;
}

static int ar_replace_new_thin (char *archive_name, int memc, char **members, int flags) {
    size_t len;
    ssize_t name_offset;
    char *offset_str;
    char *size_str;
    char *member;
    struct ar_header hdr;
    struct stat st;

    int fd = open(archive_name, ((flags & FLAG_CREATE) ? O_CREAT : 0) | O_WRONLY, 0664); // This is the mode used by ar.

    if (fd < 0) {
        perror(archive_name);
        return EXIT_FAILURE;
    }
    if (write(fd, ARMAGT, strlen(ARMAGT)) != strlen(ARMAGT)) {
        perror("write ar header");
        return EXIT_FAILURE;
    }

    name_offset = 0;
    for (int i = 0; i < memc; i++) {
        // The full-path flag seems to have no effect in the real ar.
        member = members[i];
        len = strlen(member);
        if (len == 0)
            continue;
        // The leading ./ is not saved in the archive.
        if (len > 2 && member[0] == '.' && member[1] == '/') {
            member = &member[2];
            len -= 2;
        }
        name_offset += len + 2; // +2 for the trailing slash and newline char.
    }
    size_str = itoa(name_offset);

    memset(&hdr, ' ', sizeof(hdr));
    hdr.name[0] = '/';
    hdr.name[1] = '/';
    memcpy(&hdr.size[0], size_str, strlen(size_str));
    hdr.fmag[0] = '`';
    hdr.fmag[1] = '\n';

    if (write(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
        perror("write // to ar archive");
        return EXIT_FAILURE;
    }
    for (int i = 0; i < memc; i++) {
        // The full-path flag seems to have no effect in the real ar.
        member = members[i];
        len = strlen(member);
        if (len == 0)
            continue;
        // The leading ./ is not saved in the archive.
        if (len > 2 && member[0] == '.' && member[1] == '/') {
            member = &member[2];
            len -= 2;
        }
        if (write(fd, member, len) != len) {
            perror("write ar member long name");
            return EXIT_FAILURE;
        }
        if (write(fd, "/\n", 2) != 2) {
            perror("write ar member long name");
            return EXIT_FAILURE;
        }
    }
    
    name_offset = 0;
    for (int i = 0; i < memc; i++) {
        member = members[i];

        if (stat(member, &st) < 0) {
            perror(member);
            return EXIT_FAILURE;
        }
        itoa(st.st_size);

        len = strlen(member);
        if (len == 0)
            continue;
        // The leading ./ is not saved in the archive.
        if (len > 2 && member[0] == '.' && member[1] == '/') {
            member = &member[2];
            len -= 2;
        }
        offset_str = itoa(name_offset);
        name_offset += len + 2; // +2 for the trailing slash and newline

        memset(&hdr, ' ', sizeof(hdr));
        hdr.name[0] = '/';
        memcpy(&hdr.name[1], offset_str, strlen(offset_str));
        hdr.date[0] = '0';
        hdr.uid[0] = '0';
        hdr.gid[0] = '0';
        hdr.mode[0] = '6';
        hdr.mode[1] = '4';
        hdr.mode[2] = '4';
        /* Important: this MUST be done here, because some implementations of
        itoa are non-reentrant. */
        size_str = itoa(st.st_size);
        memcpy(&hdr.size, size_str, strlen(size_str));
        hdr.fmag[0] = '`';
        hdr.fmag[1] = '\n';

        if (write(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
            perror("write ar member header");
            return EXIT_FAILURE;
        }
    }

    return EXIT_SUCCESS;
}

static int ar_replace_new (char *archive_name, int memc, char **members, int flags) {
    if (!(flags & FLAG_THIN)) {
        puts("creating new non-thin archives not supported");
        return EXIT_FAILURE;
    }
    return ar_replace_new_thin(archive_name, memc, members, flags);
}

static int ar_replace (char *archive_name, int memc, char **members, int flags) {
    if (access(archive_name, F_OK) == EXIT_SUCCESS) {
        puts("replace not implemented");
        return EXIT_FAILURE;
    }
    return ar_replace_new(archive_name, memc, members, flags);
}


const char *USAGE_MSG = "Usage: ar <r|t|m>[csPTiDS] <archive> <members...>";
static void print_usage () {
    puts(USAGE_MSG);
}

/*
Uses in Lnux:
ar cDPrST (tons of occurrences)
ar t (only two uses)
ar mPiT $(ar t vmlinux.a | sed -n 1p) vmlinux.a $(ar t vmlinux.a | grep -F -f ./scripts/head-object-list.txt)
ar rcs /build/stage/src/linux/tools/objtool/libsubcmd/libsubcmd.a /build/stage/src/linux/tools/objtool/libsubcmd/libsubcmd-in.o

Operations:
r = Insert the files member... into archive (with replacement)
t = Display a table listing the contents of archive, or those of the files
    listed in member... that are present in the archive.  Normally only the
    member name is shown...
m = Use this operation to move members in an archive.

Modifiers:
c = Create the archive. (O_CREAT)
s = Add an index to the archive, or update it if it already exists. (also an op)
P = Use the full path name when matching or storing names in the archive.
T = Make the specified archive a thin archive.
i = Insert new files before an existing member of the archive.
D = Operate in deterministic mode. (Zero uids, gids, timestamps, etc.)
S = Do not generate an archive symbol table.

ar t output looks like:
init/main.o
init/version.o
init/do_mounts.o
...

"ar t vmlinux.a | sed -n 1p" looks like:
init/main.o

(That's it. Just one line.)

"ar t vmlinux.a | grep -F -f ./scripts/head-object-list.txt" fails (exit 1)...

The third invocation above means "move/insert the following members to be before
the argument specified in [relpos]" and since the relpos argument is just the
first file in the archive, it effectively means, "put these members at the top
of the archive."

...and upon looking in the head-object-list.txt, because none of the objects in
that list are even compiled on x86-64. It looks like this is a no-op on x86-64,
so I think I am going to just implement a stub.

*/
int main (int argc, char **argv) {
    int type = SUBCMD_UNKNOWN;
    int flags = 0;
    int i;
    char *archive_name;
    char **members;
    int fd;

    if (argc < 3)
        goto usage;

    for (i = 0; i < strlen(argv[1]); i++) {
        switch (argv[1][i]) {
        case 'r':
            if (type != SUBCMD_UNKNOWN)
                goto usage;
            type = SUBCMD_REPLACE;
            break;
        case 't':
            if (type != SUBCMD_UNKNOWN)
                goto usage;
            type = SUBCMD_LIST;
            break;
        case 'm':
            if (type != SUBCMD_UNKNOWN)
                goto usage;
            type = SUBCMD_MOVE;
            break;
        case 'c':
            flags |= FLAG_CREATE;
            break;
        case 's':
            flags |= FLAG_INDEX;
            break;
        case 'P':
            flags |= FLAG_FULL_PATH;
            break;
        case 'T':
            flags |= FLAG_THIN;
            break;
        case 'i':
            flags |= FLAG_INSERT;
            break;
        case 'D':
            flags |= FLAG_DETERM;
            break;
        case 'S':
            flags |= FLAG_NO_SYMS;
            break;
        default:
            break;
        }
    }

    archive_name = argv[2];
    members = &argv[3];

    switch (type) {
    case SUBCMD_LIST:
        return ar_list(archive_name, flags);
    case SUBCMD_MOVE:
        return ar_move(archive_name, flags);
    case SUBCMD_REPLACE:
        return ar_replace(archive_name, argc - 3, members, flags);
    default:
        return EXIT_FAILURE;
    }

usage:
    print_usage();
    return EXIT_FAILURE;
}