/*
Minimal implementation of the cut Unix program by Jonathan M. Wilbur.
Compiles against nolibc.

The only place this is used to build the Linux kernel is: cut -b -64
This means "take the first 64 bytes" (from stdin).
*/
#ifndef NOLIBC
#define _GNU_SOURCE
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int atoi (const char* s) {
    int ret = 0;
    for (int i = 0; i < strlen(s); i++) {
        char c = s[i];
        if (!isdigit(c))
            break;
        ret = (ret * 10) + (c - '0');
    }
    return ret;
}

#else
#define BUFSIZ      8192
#endif

#define FLAG_ZERO_TERM      (1 << 0)
#define FLAG_COMPLEMENT     (1 << 1)
#define FLAG_ONLY_DELIM     (1 << 2)

#define CUT_UNSET           0
#define CUT_BYTES           1
#define CUT_CHARS           2
#define CUT_FIELDS          3

#define BOUND_UNSET         0

const char *USAGE = "cut [-b] [FILE...]";
static void print_usage () {
    puts(USAGE);
}

typedef struct {
    size_t start;  // Start of range, -1 if not specified
    size_t end;    // End of range, -1 if not specified
} Range;

static char linebuf[BUFSIZ];
static int linebufsize = 0;

/* An absolutely STINKY implementation for the sake of simplicity. */
static char *readline(int fd, char delim) {
    char c;
    char *line;
    ssize_t rc;

    while (1) {
        rc = read(fd, &c, 1);
        if (rc < 0) {
            perror("read");
            return NULL;
        }
        if (delim == '\n' && c == '\r')
            continue;
        if (c == delim || rc == 0)
            break;
        linebuf[linebufsize++] = (char)c;
    }
    line = malloc(linebufsize + 1);
    if (line == NULL)
        return NULL;
    if (linebufsize == 0 && rc == 0)
        return NULL;
    memcpy(line, linebuf, linebufsize);
    line[linebufsize] = 0;  // Add null terminator.
    linebufsize = 0;
    return line;
}

// Generated by ChatGPT
Range parse_range(const char *range_str) {
    Range range = {BOUND_UNSET, BOUND_UNSET};  // Default: unspecified range

    if (!range_str || *range_str == '\0') {
        return range;  // Return default for empty input
    }

    char *dash = strchr(range_str, '-');
    if (!dash) {
        // No dash: single number
        if (isdigit(*range_str)) {
            range.start = atoi(range_str);
            range.end = range.start;
        }
    } else {
        // Dash found
        if (dash == range_str) {
            // Starts with dash, e.g., "-5"
            range.end = atoi(dash + 1);
        } else if (*(dash + 1) == '\0') {
            // Ends with dash, e.g., "5-"
            range.start = atoi(range_str);
        } else {
            // Full range, e.g., "1-5"
            range.start = atoi(range_str);
            range.end = atoi(dash + 1);
        }
    }

    // These fields are 1-indexed for some dumb reason!
    if (range.start > 0)
        range.start--;
    return range;
}

// Generated by ChatGPT
// Safe write: Ensures the write operation completes unless another error occurs.
ssize_t safe_write(int fd, const void *buf, size_t count) {
    ssize_t total_written = 0; // Total bytes written
    const char *buffer = (const char *)buf;

    while (total_written < (ssize_t)count) {
        ssize_t bytes_written = write(fd, buffer + total_written, count - total_written);
        if (bytes_written > 0) {
            total_written += bytes_written; // Update total bytes written
        } else if (bytes_written == 0) {
            // Should not happen for write, but handle gracefully
            break;
        } else if (errno == EINTR) {
            // Interrupted by a signal, retry the write
            continue;
        } else {
            // Some other error occurred
            return -1;
        }
    }

    return total_written;
}

static int prefix (const char *pre, const char *str) {
    return strncmp(pre, str, strlen(pre)) == 0;
}

#define MIN(x, y) ((x) < (y) ? (x) : (y))

int cut_bytes (int ifd, int ofd, int flags, Range range) {
    int contains_delimiter = 0; // For use with FLAG_ONLY_DELIM
    int line_delim = (flags & FLAG_ZERO_TERM) ? '\0' : '\n';
    size_t start = range.start != BOUND_UNSET ? range.start : 0;
    size_t end = range.end != BOUND_UNSET ? range.end : SIZE_MAX;
    if (start >= end)
        return EXIT_FAILURE;
    size_t len = end - start;
    char *line;

    while (line = readline(ifd, line_delim)) {
        size_t line_len = strlen(line);
        if (line_len < start)
            continue;
        size_t write_len = MIN(line_len - start, len);
        if (safe_write(ofd, &line[start], write_len) < 0) {
            perror("write");
            return EXIT_FAILURE;
        }
        free(line);
        if (write(ofd, &line_delim, 1) < 0) {
            perror("write");
            return EXIT_FAILURE;
        }
    }
    return EXIT_SUCCESS;
}

// For now, we're assuming one character is one byte.
int cut_chars (int ifd, int ofd, int flags, Range range) {
    return cut_bytes (ifd, ofd, flags, range);
}

int cut_fields (int ifd, int ofd, int flags, char idel, char odel, Range range) {
    int contains_delimiter = 0; // For use with FLAG_ONLY_DELIM
    int line_delim = (flags & FLAG_ZERO_TERM) ? '\0' : '\n';
    size_t start = range.start != BOUND_UNSET ? range.start : 0;
    size_t end = range.end != BOUND_UNSET ? range.end : SIZE_MAX;
    if (start >= end)
        return EXIT_FAILURE;
    char *line;

    while (line = readline(ifd, line_delim)) {
        int wrote_a_field = 0;
        size_t line_len = strlen(line);
        size_t start_of_field = 0;
        size_t field = 0;
        for (size_t i = 0; i < line_len + 1; i++) {
            if (line[i] != idel && line[i] != '\0')
                continue;
            // Check if the field is in range
            if ((field < start) || (field >= end)) {
                goto next;
            }
            if (wrote_a_field && write(ofd, &odel, 1) < 0) {
                perror("write");
                return EXIT_FAILURE;
            }
            wrote_a_field = 1;
            size_t len = i - start_of_field;
            if (safe_write(ofd, &line[start_of_field], len) < 0) {
                perror("write");
                return EXIT_FAILURE;
            }
        next:
            field++;
            start_of_field = i + 1;
        }
        if (
            !(flags & FLAG_ONLY_DELIM)
            && field == 0
            && (safe_write(ofd, line, line_len) < 0)) {
            perror("write");
            return EXIT_FAILURE;
        }
        free(line);
        if (write(ofd, &line_delim, 1) < 0) {
            perror("write");
            return EXIT_FAILURE;
        }
    }
    return EXIT_SUCCESS;
}

int cut (int cut_type, int ifd, int ofd, int flags, char idel, char odel, Range range) {
    switch (cut_type) {
        case (CUT_BYTES):   return cut_bytes (ifd, ofd, flags, range);
        case (CUT_CHARS):   return cut_chars (ifd, ofd, flags, range);
        case (CUT_FIELDS):  return cut_fields(ifd, ofd, flags, idel, odel, range);
        default: {
            puts("unrecognized cut type");
            return EXIT_FAILURE;
        }
    }
}

#define NEXT_ARG_NONE       0
#define NEXT_ARG_BYTES      1
#define NEXT_ARG_CHARS      2
#define NEXT_ARG_FIELDS     3
#define NEXT_ARG_DELIM      4
#define NEXT_ARG_OUT_DELIM  5

int main (int argc, char **argv) {
    int flags = 0;
    int i = 0;
    char *arg;
    char *delim = "\t";
    char *output_delim = delim;
    char *list = NULL;
    int cut_type = CUT_UNSET;
    int lower, upper;
    int next_arg = NEXT_ARG_NONE;
    size_t arglen;
    char **files;
    int ifd = STDIN_FILENO;
    int ofd = STDOUT_FILENO;

    if (argc < 2) {
        print_usage();
        return EXIT_FAILURE;
    }

    i = 1;
    for (; i < argc; i++) {
        arg = argv[i];
        arglen = strlen(arg);
        if (arglen == 0)
            continue;
        switch (next_arg) {
        case NEXT_ARG_NONE:
            break;
        case NEXT_ARG_BYTES:
        case NEXT_ARG_CHARS:
        case NEXT_ARG_FIELDS:
            list = arg;
            break;
        case NEXT_ARG_DELIM:
            delim = arg;
            break;
        case NEXT_ARG_OUT_DELIM:
            output_delim = arg;
            break;
        default:
            puts("Internal error when parsing command line arguments.");
            return EXIT_FAILURE;
        }
        if (next_arg != NEXT_ARG_NONE) {
            next_arg = NEXT_ARG_NONE;
            continue; // We already handled it.
        }

parse_short_args:
        if (arglen == 2 && arg[0] == '-') {
            switch (arg[1]) {
            case 'b':
                cut_type = CUT_BYTES;
                next_arg = NEXT_ARG_BYTES;
                continue;
            case 'c':
                cut_type = CUT_CHARS;
                next_arg = NEXT_ARG_CHARS;
                continue;
            case 'd':
                next_arg = NEXT_ARG_DELIM;
                continue;
            case 'f':
                cut_type = CUT_FIELDS;
                next_arg = NEXT_ARG_FIELDS;
                continue;
            case 'n':
                continue;
            case 's':
                flags |= FLAG_ONLY_DELIM;
                continue;
            case 'z':
                flags |= FLAG_ZERO_TERM;
                continue;
            }
        }

parse_long_args:
        if (!strcmp(arg, "--bytes")) {
            cut_type = CUT_BYTES;
            next_arg = NEXT_ARG_BYTES;
            continue;
        }
        else if (!strcmp(arg, "--chars")) {
            cut_type = CUT_CHARS;
            next_arg = NEXT_ARG_CHARS;
            continue;
        }
        else if (!strcmp(arg, "--fields")) {
            cut_type = CUT_FIELDS;
            next_arg = NEXT_ARG_FIELDS;
            continue;
        }
        else if (!strcmp(arg, "--delimiter")) {
            next_arg = NEXT_ARG_DELIM;
            continue;
        }
        else if (!strcmp(arg, "--output-delimiter")) {
            next_arg = NEXT_ARG_OUT_DELIM;
            continue;
        }
        else if (!strcmp(arg, "--complement")) {
            puts("Your hair looks great today!");
            return EXIT_FAILURE;
        }
        else if (!strcmp(arg, "--only-delimited")) {
            flags |= FLAG_ONLY_DELIM;
            continue;
        }
        else if (!strcmp(arg, "--zero-terminated")) {
            flags |= FLAG_ZERO_TERM;
            continue;
        }
        else if (prefix("--bytes=", arg)) {
            cut_type = CUT_BYTES;
            list = &arg[strlen("--bytes=")];
            continue;
        }
        else if (prefix("--chars=", arg)) {
            cut_type = CUT_CHARS;
            list = &arg[strlen("--chars=")];
            continue;
        }
        else if (prefix("--fields=", arg)) {
            cut_type = CUT_FIELDS;
            list = &arg[strlen("--fields=")];
            continue;
        }
        else if (prefix("--delimiter=", arg)) {
            delim = &arg[strlen("--delimiter=")];
            continue;
        }
        else if (prefix("--output-delimiter=", arg)) {
            output_delim = &arg[strlen("--output-delimiter=")];
            continue;
        }
        else if (arg[0] == '-') {
            if (arglen == 1)
                break;
            printf("Option not understood: %s\n", arg);
            return EXIT_FAILURE;
        }
        else {
            break;
        }
    }

    if (strlen(delim) != 1) {
        puts("Delimiter must be only one character");
        return EXIT_FAILURE;
    }
    if (strlen(output_delim) != 1) {
        puts("Output delimiter must be only one character");
        return EXIT_FAILURE;
    }

    char idel = delim[0];
    char odel = output_delim[0];
    Range range = parse_range(list);

    files = &argv[i];

    if (i >= argc)
        return cut(cut_type, ifd, ofd, flags, idel, odel, range);
    while (i < argc) {
        ifd = open(argv[i++], O_RDONLY);
        if (ifd < 0) {
            perror("cut @ read");
            return EXIT_FAILURE;
        }
        if (cut(cut_type, ifd, ofd, flags, idel, odel, range) != EXIT_SUCCESS)
            return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
