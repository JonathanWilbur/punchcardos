/*
bc, but only for building the Linux Kernel

by Jonathan M. Wilbur

The Linux kernel requires a the GNU `bc` tool to be able to compile. From what
I can see, the only thing it actually needs this for is to generate the file
`include/generated/timeconst.h` according to the script in
`kernel/time/timeconst.bc`. (`bc` is used for tests, however.)

This is a problem for bootstrapping a Linux kernel, because it requires yet
another tool that you have to build, using other tools, ad nauseum, and for
such a trivial task!

I had the clever idea to write a fake `bc` that does nothing other than generate
this file, thereby trimming down the dependencies needed to build the Linux
kernel by one.

This tool builds with:

- glibc
- (probably) musl libc
- nolibc (Part of the Linux kernel code in `tools/include/nolibc`)
- no standard library at all

## Building

### glibc build

```bash
gcc -o bc ./bc4linux.c 
```

### nolibc build

```bash
gcc -o bc -static -nostdlib -include PATH_TO_LINUX/tools/include/nolibc/nolibc.h ./bc4linux.c
```

### No standard library build

Warning: this only works on Linux on x86-64.

```bash
gcc -o bc -DNO_STD_LIB ./bc4linux.c
```

## Using

Pipe a decimal number (the value of `CONFIG_HZ`) into the command like so:

```bash
echo '250' | ./bc
```

Any command line arguments are just ignored.

*/
#ifndef NO_STD_LIB

#ifndef NOLIBC
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#ifdef __GLIBC__
#include <stdio.h>

// WARNING: This is non-reentrant.
char* itoa (long in) {
    static char buf[100];
    sprintf(buf, "%ld", in);
    return &buf[0];
}

// End of ifdef __GLIBC__
#endif

// End of ifndef NOLIBC
#endif

// !ifndef NO_STD_LIB
#else

#define SYSCALL_READ 0
#define SYSCALL_WRITE 1

static int write (unsigned fd, const char *buf, long count)
{
    unsigned ret;

    asm volatile
    (
        "syscall"
        : "=a"(ret)
        : "a"(SYSCALL_WRITE), "D"(fd), "S"(buf), "d"(count)
        : "rcx", "r11", "memory"
    );

    return ret;
}

static long read (int fd, void *buf, long count) {
    long _ret;
	register long _num  __asm__ ("rax") = (SYSCALL_READ);
	register long _arg1 __asm__ ("rdi") = (long)(fd);
	register long _arg2 __asm__ ("rsi") = (long)(buf);
	register long _arg3 __asm__ ("rdx") = (long)(count);

	__asm__ volatile (
		"syscall\n"
		: "=a"(_ret)
		: "r"(_arg1), "r"(_arg2), "r"(_arg3),
		  "0"(_num)
		: "rcx", "r11", "memory", "cc"
	);
	_ret;
}

long strlen (const char *str)
{
	long len = 0;

	for (len = 0; str[len]; len++)
// We can't assume a hyper-minimal compiler supports assembly.
#ifdef __GNUC__
		__asm__("");
#else
        ;
#endif
	return len;
}

char* itoa (long in) {
    static char buffer[21];
	unsigned long lim;
	int digits = 0;
	int pos = (~0UL > 0xfffffffful) ? 19 : 9;
	int dig;

	do {
		for (dig = 0, lim = 1; dig < pos; dig++)
			lim *= 10;

		if (digits || in >= lim || !pos) {
			for (dig = 0; in >= lim; dig++)
				in -= lim;
			buffer[digits++] = '0' + dig;
		}
	} while (pos--);

	buffer[digits] = 0;
	return buffer;
}

int atoi (const char* s) {
    int ret = 0;
    for (int i = 0; i < strlen(s); i++) {
        char c = s[i];
        if (c < '0' || c > '9') {
            break;
        }
        ret = (ret * 10) + (c - '0');
    }
    return ret;
}

#endif // End of !ifndef NO_STD_LIB

#define HUGEINT unsigned long long

#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1

#define STDIN_FILENO        0
#define STDOUT_FILENO       1

const char *HEADER = "/* Automatically generated by kernel/time/timeconst.bc */\n"
    "#ifndef KERNEL_TIMECONST_H\n"
    "#define KERNEL_TIMECONST_H\n\n"
    "#include <linux/param.h>\n"
    "#include <linux/types.h>\n\n";

const char* FOOTER = "\n#endif /* KERNEL_TIMECONST_H */\n";

const char* DEFINE_01 = "#define HZ_TO_MSEC_MUL32\tU64_C(";
const char* DEFINE_02 = "#define HZ_TO_MSEC_ADJ32\tU64_C(";
const char* DEFINE_03 = "#define HZ_TO_MSEC_SHR32\t";
const char* DEFINE_04 = "#define MSEC_TO_HZ_MUL32\tU64_C(";
const char* DEFINE_05 = "#define MSEC_TO_HZ_ADJ32\tU64_C(";
const char* DEFINE_06 = "#define MSEC_TO_HZ_SHR32\t";
const char* DEFINE_07 = "#define HZ_TO_MSEC_NUM\t\t";
const char* DEFINE_08 = "#define HZ_TO_MSEC_DEN\t\t";
const char* DEFINE_09 = "#define MSEC_TO_HZ_NUM\t\t";
const char* DEFINE_10 = "#define MSEC_TO_HZ_DEN\t\t";
const char* DEFINE_11 = "#define HZ_TO_USEC_MUL32\tU64_C(";
const char* DEFINE_12 = "#define HZ_TO_USEC_ADJ32\tU64_C(";
const char* DEFINE_13 = "#define HZ_TO_USEC_SHR32\t";
const char* DEFINE_14 = "#define USEC_TO_HZ_MUL32\tU64_C(";
const char* DEFINE_15 = "#define USEC_TO_HZ_ADJ32\tU64_C(";
const char* DEFINE_16 = "#define USEC_TO_HZ_SHR32\t";
const char* DEFINE_17 = "#define HZ_TO_USEC_NUM\t\t";
const char* DEFINE_18 = "#define HZ_TO_USEC_DEN\t\t";
const char* DEFINE_19 = "#define USEC_TO_HZ_NUM\t\t";
const char* DEFINE_20 = "#define USEC_TO_HZ_DEN\t\t";
const char* DEFINE_21 = "#define HZ_TO_NSEC_NUM\t\t";
const char* DEFINE_22 = "#define HZ_TO_NSEC_DEN\t\t";
const char* DEFINE_23 = "#define NSEC_TO_HZ_NUM\t\t";
const char* DEFINE_24 = "#define NSEC_TO_HZ_DEN\t\t";

HUGEINT fmul (HUGEINT b, HUGEINT n, HUGEINT d) {
    // (2^b*n+d-1)/d
    return (((1ULL << b) * n) + d - 1ULL) / d;
}

HUGEINT fmuls (HUGEINT b, HUGEINT n, HUGEINT d) {
    HUGEINT s, m;
	for (s = 0ULL; 1; s++) {
		m = fmul(s, n, d);
		if (m >= (1ULL << (b - 1ULL)))
			return s;
	}
	return 0;
}

HUGEINT gcd (HUGEINT a, HUGEINT b) {
	HUGEINT t;
	while (b) {
		t = b;
		b = a % b;
		a = t;
	}
	return a;
}

HUGEINT fadj (HUGEINT b, HUGEINT n, HUGEINT d) {
    HUGEINT v;
    d = d / gcd(n, d);
    v = ((1ULL << b) * (d - 1ULL)) / d;
    return v;
}

#define WRITE(x)    if (write(STDOUT_FILENO, x, strlen(x)) <= 0) return EXIT_FAILURE;

/* Unlike the original, always outputs in base-10. Hopefully this is okay! */
int timeconst (long hz) {
    HUGEINT s = fmuls(32ULL, 1000ULL, hz);
    HUGEINT cd;
    char* tmp;

    WRITE(HEADER)

    // Not really necessary.
	// print "#if HZ != ", hz, "\n"
	// print "#error \qinclude/generated/timeconst.h has the wrong HZ value!\q\n"
	// print "#endif\n\n"

    WRITE(DEFINE_01)
    tmp = itoa(fmul(s, 1000ULL, hz));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define HZ_TO_MSEC_ADJ32\tU64_C(0x", fadj(s,1000,hz), ")\n"
    WRITE(DEFINE_02)
    tmp = itoa(fadj(s, 1000ULL, hz));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define HZ_TO_MSEC_SHR32\t", s, "\n"
    WRITE(DEFINE_03)
    tmp = itoa(s);
    WRITE(tmp)
    WRITE("\n")

    s = fmuls(32ULL, hz, 1000ULL);
    // print "#define MSEC_TO_HZ_MUL32\tU64_C(0x", fmul(s,hz,1000), ")\n"
    WRITE(DEFINE_04)
    tmp = itoa(fmul(s, hz, 1000ULL));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define MSEC_TO_HZ_ADJ32\tU64_C(0x", fadj(s,hz,1000), ")\n"
    WRITE(DEFINE_05)
    tmp = itoa(fadj(s, hz, 1000ULL));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define MSEC_TO_HZ_SHR32\t", s, "\n"
    WRITE(DEFINE_06)
    tmp = itoa(s);
    WRITE(tmp)
    WRITE("\n")

    cd = gcd(hz, 1000ULL);

    // print "#define HZ_TO_MSEC_NUM\t\t", 1000/cd, "\n"
    WRITE(DEFINE_07)
    tmp = itoa(1000ULL / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define HZ_TO_MSEC_DEN\t\t", hz/cd, "\n"
    WRITE(DEFINE_08)
    tmp = itoa(hz / cd);
    WRITE(tmp)
    WRITE("\n")

    // TODO: Is this a bug? This is the same as the above...
    // print "#define MSEC_TO_HZ_NUM\t\t", hz/cd, "\n"
    WRITE(DEFINE_09)
    tmp = itoa(hz / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define MSEC_TO_HZ_DEN\t\t", 1000/cd, "\n"
    WRITE(DEFINE_10)
    tmp = itoa(1000ULL / cd);
    WRITE(tmp)
    WRITE("\n\n")

    s = fmuls(32ULL, 1000000ULL, hz);
    // print "#define HZ_TO_USEC_MUL32\tU64_C(0x", fmul(s,1000000,hz), ")\n"
    WRITE(DEFINE_11)
    tmp = itoa(fmul(s, 1000000ULL, hz));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define HZ_TO_USEC_ADJ32\tU64_C(0x", fadj(s,1000000,hz), ")\n"
    WRITE(DEFINE_12)
    tmp = itoa(fadj(s, 1000000ULL, hz));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define HZ_TO_USEC_SHR32\t", s, "\n"
    WRITE(DEFINE_13)
    tmp = itoa(s);
    WRITE(tmp)
    WRITE("\n")

    s=fmuls(32ULL, hz, 1000000ULL);

    // print "#define USEC_TO_HZ_MUL32\tU64_C(0x", fmul(s,hz,1000000), ")\n"
    WRITE(DEFINE_14)
    tmp = itoa(fmul(s, hz, 1000000ULL));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define USEC_TO_HZ_ADJ32\tU64_C(0x", fadj(s,hz,1000000), ")\n"
    WRITE(DEFINE_15)
    tmp = itoa(fadj(s, hz, 1000000ULL));
    WRITE(tmp)
    WRITE(")\n")

    // print "#define USEC_TO_HZ_SHR32\t", s, "\n"
    WRITE(DEFINE_16)
    tmp = itoa(s);
    WRITE(tmp)
    WRITE("\n")

    cd = gcd(hz, 1000000ULL);
    // print "#define HZ_TO_USEC_NUM\t\t", 1000000/cd, "\n"
    WRITE(DEFINE_17)
    tmp = itoa(1000000ULL / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define HZ_TO_USEC_DEN\t\t", hz/cd, "\n"
    WRITE(DEFINE_18)
    tmp = itoa(hz / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define USEC_TO_HZ_NUM\t\t", hz/cd, "\n"
    WRITE(DEFINE_19)
    tmp = itoa(hz / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define USEC_TO_HZ_DEN\t\t", 1000000/cd, "\n"
    WRITE(DEFINE_20)
    tmp = itoa(1000000ULL / cd);
    WRITE(tmp)
    WRITE("\n")

    cd = gcd(hz, 1000000000ULL);

    // print "#define HZ_TO_NSEC_NUM\t\t", 1000000000/cd, "\n"
    WRITE(DEFINE_21)
    tmp = itoa(1000000000ULL / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define HZ_TO_NSEC_DEN\t\t", hz/cd, "\n"
    WRITE(DEFINE_22)
    tmp = itoa(hz / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define NSEC_TO_HZ_NUM\t\t", hz/cd, "\n"
    WRITE(DEFINE_23)
    tmp = itoa(hz / cd);
    WRITE(tmp)
    WRITE("\n")

    // print "#define NSEC_TO_HZ_DEN\t\t", 1000000000/cd, "\n"
    WRITE(DEFINE_24)
    tmp = itoa(1000000000ULL / cd);
    WRITE(tmp)
    WRITE("\n")

    WRITE(FOOTER)

    return EXIT_SUCCESS;
}

int main (int argc, char **argv) {
    long hz;
    char buf[100] = { 0 };
    int read_len = 0;
    if ((read_len = read(STDIN_FILENO, &buf, 99)) <= 0)
        return EXIT_FAILURE;
    buf[read_len] = 0; // Add null terminator.
    hz = atoi((const char *)&buf);
    if (hz < 2)
        return EXIT_FAILURE;
    return timeconst(hz);
}